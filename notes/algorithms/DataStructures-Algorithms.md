

## 动态规划的思想
动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。


## 快速排序的思想
在数组中找到一个基准数（pivot）
分区，将数组中比基准数大的放到它的右边，比基准数小的放到它的左边
继续对左右区间重复第二步，直到各个区间只有一个数，这时候，数组也就有序了。

## 快速排序算法是不稳定的算法
27 23 27 3
以第一个27作为pivot中心点，则27与后面那个3交换，形成
3 23 27 27，排序经过一次结束，但最后那个27在排序之初先于初始位置3那个27，所以不稳定。


## 堆排序的思想
利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。


其基本思想为(大顶堆)：
1. 将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无须区；
2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]; 
3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。




## 字典树
![](https://github.com/zaiyunduan123/Java-Interview/blob/master/image/algorithms-1.jpg) 

字典树主要有如下三点性质：
1. 根节点不包含字符，除根节点意外每个节点只包含一个字符。
2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符串不相同。

## 链表反转

1. 首先让头节点与第一个元素节点断开，但是要注意在断开之前需要用p指针指向第一个元素节点来保存第一个元素节点的位置，然后再断开。在这里有一个指针q指向一个指针域为空的节点，这个节点用来做为链表反转后的最后一个节点。
2. 让第二个元素节点的指针从指向第三个元素节点变为指向第一个元素节点，以此类推，直至指针p指向原链表最后一个元素。
3. p指针指向NULL时，让原头节点的指针域指向原来最后一个元素节点。此时链表倒置已完成。

```java
    // 反转单向链表
	public static Node reverseList(Node head) {
		Node next = null;
		Node pre = null;
		while (head != null) {
			next = head.next;// 备份
			head.next = pre;// 将头节点的下一个节点指向空（pre）
			pre = head;// pre指向原来的头节点
			head = next;// 头节点变为了它的下一节点（向下移动了一位）
		}
		return pre;// 因为head是在为空的时候退出的循环，所以应该返回他的上一节点
	}

}
```